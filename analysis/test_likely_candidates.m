function test_likely_candidates(cellid, training_set, test_set)
% Exhaustively test the most likely model structures candidates for fitting
% Kind of throws the entire kitchen, including the sink, at the problem
% Very slow. Probably will take an entire day.

% NOT VERY USEFUL ANYMORE:
% Return a list of modules with a specified field varying
function [mlist, mstrings] =  vary_module(mdl, field, values)
    mlist = cell(1, length(values));
    mstrings = cell(1, length(values));
    for ii = 1:length(values)
        mlist{ii} = mdl.mdl(struct(field, values{ii}));
        mstrings{ii} = [field '=' repl_write(values{ii}) '_'];
    end
end

% Although it is tempting to make this less verbose and refactor, if you
% want to allow multiple different modules to be tried in the same
% iteration, it's hard to get much more abstract than this. 
% 
% Basically, you make a nested list of possible modules to test:
poss{1} = ...
    {@(stack) mdls.load_stim_resps_from_baphy.mdl(struct('raw_resp_fs', 200, ...
                                                         'raw_stim_fs', 20000)), ...
     @(stack) mdls.load_stim_resps_from_baphy.mdl(struct('raw_resp_fs', 100, ...
                                                         'raw_stim_fs', 20000)), ...                                                    
     @(stack) mdls.load_stim_resps_from_baphy.mdl(struct('raw_resp_fs', 200, ...
                                                         'raw_stim_fs', 100000))};

bands = logspace(log10(250), log10(8000), 11);
poss{2} = ...
    {@(stack) mdls.gammatone_filter_bank.mdl(struct('num_channels', 10, ...
                                                    'bank_min_freq', 250, ...
                                                    'bank_max_freq', 8000)), ...
     @(stack) mdls.gammatone_filter_bank.mdl(struct('num_channels', 10, ...
                                                    'bank_min_freq', 250, ...
                                                    'bank_max_freq', 8000, ...
                                                    'align_phase', 1)), ...
     @(stack) mdls.elliptic_bandpass_filter_bank.mdl(struct('num_channels', 10, ...
                                                            'low_freqs', bands(1:end-1), ...
                                                            'high_freqs', bands(2:end)))};
     
poss{3} = ...
    {@(stack) mdls.downsample_with_fn.mdl(struct('downsampled_freq', stack{1}.raw_resp_fs, ...
                                                 'postconv_fn', @sqrt)), ...
     @(stack) mdls.downsample_with_fn.mdl(struct('downsampled_freq', stack{1}.raw_resp_fs, ...
                                                 'postconv_fn', @(x) x)), ...
     @(stack) mdls.downsample_with_fn.mdl(struct('downsampled_freq', stack{1}.raw_resp_fs, ...
                                                 'postconv_fn', @(x) log(x + 10^-6)))};

poss{4} = ...
    {@(stack) mdls.fir_filter.mdl(struct('num_dims', 10, ...
                                         'fit_fields', {{'coefs'}})), ...
     @(stack) mdls.fir_filter.mdl(struct('num_dims', 10, ...
                                         'fit_fields', {{'coefs'}}))};
                                         
poss{5} = ...
    {@(stack) mdls.step_filter.mdl(struct('inputs', {{'fir_out'}}, ...
                                          'outputs', {{'nl_out'}})), ...
     @(stack) mdls.exp_filter.mdl(struct('inputs', {{'fir_out'}}, ...
                                          'outputs', {{'nl_out'}})), ...
     @(stack) mdls.sigmoid_filter.mdl(struct('inputs', {{'fir_out'}}, ...
                                          'outputs', {{'nl_out'}}))};
 
poss{6} = ...
    {@(stack) mdls.sum_filter.mdl(struct('input_field', {{'nl_out'}}))};

% TEST LOOP
% Set up STACK for each ordered POSSIBILITY permutation and recalc once
%     Recalc once
%     Fit model
%     record performance
%     Record coefficients
%     Write down good string filename
%     Save under that string
