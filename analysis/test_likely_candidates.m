function test_likely_candidates(cellid, training_set, test_set)
% Exhaustively test the most likely model structures candidates for fitting
% Kind of throws the entire kitchen, including the sink, at the problem
% Very slow. Probably will take an entire day to run.
%
% Although it is tempting to make this less verbose and refactor, if you
% want to allow multiple different modules to be tried in the same
% iteration, it's hard to get much more abstract than this. 
%
% TODO: At some point we may wish to generate models with
% a different number of modules; some models may have 3 components and
% others may have 6. I think that in such cases we will need to allow
% nested lists, so that POSS has a second layer of structure indicating
% which MULTIPLE model structures need to be inserted at once to make the
% stack. This means that there is not a direct mapping of POSS index number
% to the actual depth in the stack.
% 
% Basically, you make a nested list of possible modules to test:
poss{1} = ...
    {@(stack) mdls.load_stim_resps_from_baphy.mdl(struct('raw_resp_fs', 200, ...
                                                         'raw_stim_fs', 20000)), ...
     @(stack) mdls.load_stim_resps_from_baphy.mdl(struct('raw_resp_fs', 100, ...
                                                         'raw_stim_fs', 20000)), ...                                                    
     @(stack) mdls.load_stim_resps_from_baphy.mdl(struct('raw_resp_fs', 500, ...
                                                         'raw_stim_fs', 100000))};

bands = logspace(log10(250), log10(8000), 11);
poss{2} = ...
    {@(stack) mdls.gammatone_filter_bank.mdl(struct('num_channels', 10, ...
                                                    'bank_min_freq', 250, ...
                                                    'bank_max_freq', 8000)), ...
     @(stack) mdls.gammatone_filter_bank.mdl(struct('num_channels', 10, ...
                                                    'bank_min_freq', 250, ...
                                                    'bank_max_freq', 8000, ...
                                                    'align_phase', 1)), ...
     @(stack) mdls.elliptic_bandpass_filter_bank.mdl(struct('num_channels', 10, ...
                                                            'low_freqs', bands(1:end-1), ...
                                                            'high_freqs', bands(2:end)))};
     
poss{3} = ...
    {@(stack) mdls.downsample_with_fn.mdl(struct('downsampled_freq', stack{1}.raw_resp_fs, ...
                                                 'postconv_fn', @sqrt)), ...
     @(stack) mdls.downsample_with_fn.mdl(struct('downsampled_freq', stack{1}.raw_resp_fs, ...
                                                 'postconv_fn', @(x) x)), ...
     @(stack) mdls.downsample_with_fn.mdl(struct('downsampled_freq', stack{1}.raw_resp_fs, ...
                                                 'postconv_fn', @(x) log(x + 10^-6)))};

poss{4} = ...
    {@(stack) mdls.fir_filter.mdl(struct('num_dims', 10, ...
                                         'fit_fields', {{'coefs'}})), ...
     @(stack) mdls.fir_filter.mdl(struct('num_dims', 10, ...
                                         'fit_fields', {{'coefs'}}))};
                                         
poss{5} = ...
    {@(stack) mdls.step_filter.mdl(struct('inputs', {{'fir_out'}}, ...
                                          'outputs', {{'nl_out'}})), ...
     @(stack) mdls.exp_filter.mdl(struct('inputs', {{'fir_out'}}, ...
                                          'outputs', {{'nl_out'}})), ...
     @(stack) mdls.sigmoid_filter.mdl(struct('inputs', {{'fir_out'}}, ...
                                          'outputs', {{'nl_out'}}))};
 
poss{6} = ...
    {@(stack) mdls.sum_filter.mdl(struct('input', {{'nl_out'}}))};

% TEST LOOP
% Set up STACK for each ordered POSSIBILITY permutation and recalc once
%     Recalc once
%     Fit model
%     record performance
%     Record coefficients
%     Write down good string filename
%     Save under that string
