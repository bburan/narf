
mm = {}; 

% GROUP 1: LOADING A DOWNSAMPLED, POSITIVE SEMIDEFINITE SIGNAL
mm{1} = [];
% mm{1}.env200hz = {MODULES.load_stim_resps_from_baphy.mdl(...
%                                     struct('raw_resp_fs', 200, ...
%                                            'raw_stim_fs', 200,...
%                                            'stimulus_format', 'envelope'))};
mm{1}.env100hz = {MODULES.load_stim_resps_from_baphy.mdl(...
                                    struct('raw_resp_fs', 100, ...
                                           'raw_stim_fs', 100,...
                                           'stimulus_format', 'envelope'))};                                    
% mm{1}.wav100khz_elliptic_ds200hz = ...
%                  {MODULES.load_stim_resps_from_baphy.mdl(...
%                                     struct('raw_resp_fs', 200, ...
%                                            'raw_stim_fs', 100000)), ...
%                   MODULES.elliptic_bandpass_filter_bank, ...
%                   MODULES.downsample_with_fn.mdl(...
%                                     struct('downsampled_freq', 200, ...
%                                            'postconv_fn', @(x) x))};
% mm{1}.wav100khz_elliptic_ds100hz = ...
%                  {MODULES.load_stim_resps_from_baphy.mdl(...
%                                     struct('raw_resp_fs', 200, ...
%                                            'raw_stim_fs', 100000)), ...
%                   MODULES.elliptic_bandpass_filter_bank, ...
%                   MODULES.downsample_with_fn.mdl(...
%                                     struct('downsampled_freq', 200, ...
%                                            'conv_fn', @mean, ...
%                                            'postconv_fn', @(x) x))};

% TODO: I needed the abs() around the sqrt() because for some reason
% load_stim_from_baphy is giving negative zero values for the envelope,
% which then turn complex and crash the sigmoidal nonlinearity?

% GROUP 2: COMPRESSION OF INPUT INTENSITY
mm{2} = [];
mm{2}.nocomp = {MODULES.passthru};
% The nth-root compressors do not work as well as log compressors, but if
% you want to try them feel free.
% mm{2}.root15 = {MODULES.nonlinearity.mdl(struct('phi', [], ...
%                                                'nlfn', @(phi, z) abs(z.^(1/1.5))))};
% mm{2}.root2 = {MODULES.nonlinearity.mdl(struct('phi', [], ...
%                                                'nlfn', @(phi, z) abs(sqrt(z))))};
% mm{2}.root25 = {MODULES.nonlinearity.mdl(struct('phi', [], ...
%                                                'nlfn', @(phi, z) abs(z.^(1/2.5))))};
% mm{2}.root3 = {MODULES.nonlinearity.mdl(struct('phi', [], ...
%                                                 'nlfn', @(phi, z) abs(z.^(1/3))))};
% mm{2}.root4 = {MODULES.nonlinearity.mdl(struct('phi', [], ...
%                                                 'nlfn', @(phi, z) z.^(1/4)))};
% mm{2}.root5 = {MODULES.nonlinearity.mdl(struct('phi', [], ...
%                                                'nlfn', @(phi, z) z.^(1/5)))};
% mm{2}.rootfit = {MODULES.nonlinearity.mdl(struct('fit_fields', {{'phi'}}, ...
%                                                  'phi', [1/2.5], ...
%                                                  'nlfn', @(phi, z) abs(z.^(phi(1)))))};

% Over a population of 33 cells, some model in the range log1 to log4 was
% the best, so I don't think we need to search outside that. 
mm{2}.log1  = {MODULES.nonlinearity.mdl(struct('phi', [], ...
                                               'nlfn', @(phi, z) log(z + 10^-1)))};
mm{2}.log2  = {MODULES.nonlinearity.mdl(struct('phi', [], ...
                                               'nlfn', @(phi, z) log(z + 10^-2)))};
mm{2}.log3  = {MODULES.nonlinearity.mdl(struct('phi', [], ...
                                               'nlfn', @(phi, z) log(z + 10^-3)))};
mm{2}.log4  = {MODULES.nonlinearity.mdl(struct('phi', [], ...
                                               'nlfn', @(phi, z) log(z + 10^-4)))};
%mm{2}.log5  = {MODULES.nonlinearity.mdl(struct('phi', [], ...
%                                               'nlfn', @(phi, z) log(z + 10^-5)))};

% mm{2}.logfit  = {MODULES.nonlinearity.mdl(struct('fit_fields', {{'phi'}}, ...
%                                                  'phi', [-13], ...
%                                                  'nlfn', @(phi, z) log(z + exp(phi(1)))))};

%mm{2}.volterra = {MODULES.concat_second_order_terms}; 
%mm{2}.depress  = {MODULES.depression_filter_bank}; 

% GROUP 3: THE FIR FILTER 
mm{3} = [];
% mm{3}.fir =      {MODULES.normalize_channels, ...
%                   MODULES.fir_filter.mdl(struct('num_coefs', 12, ...
%                                                 'fit_fields', {{'coefs'}}))};
mm{3}.firbase =  {MODULES.normalize_channels, ...
                  MODULES.fir_filter.mdl(struct('num_coefs', 12, ...
                                                'fit_fields', {{'coefs', 'baseline'}}))};

                                            
                                            %mm{3}.depfir =  {MODULES.depression_filter_bank, ...
%                 MODULES.normalize_channels, ...
%                 MODULES.fir_filter.mdl(struct('num_coefs', 12, ...
%                                               'fit_fields', {{'coefs', 'baseline'}}))};

% 
% mm{3}.inhibexcit = {MODULES.normalize_channels, ...
%                     MODULES.fir_filter.mdl(struct('fit_fields', {{'coefs'}}, ...
%                                                   'num_coefs', 12, ...
%                                                   'output', 'inhib')), ...
%                     MODULES.fir_filter.mdl(struct('fit_fields', {{'coefs'}}, ...
%                                                   'num_coefs', 12, ...
%                                                   'output', 'excit')), ...                                                  
%                     MODULES.nonlinearity.mdl(struct('fit_fields', {{'phi'}}, ...
%                                                     'input_stim', 'inhib', ...
%                                                     'output', 'inhib', ...
%                                                     'phi', [0], ...
%                                                     'nlfn', @(phi, z) - zero_below_thresh(phi, z))), ...
%                     MODULES.nonlinearity.mdl(struct('fit_fields', {{'phi'}}, ...
%                                                     'input_stim', 'excit', ...
%                                                     'output', 'excit', ...
%                                                     'phi', [0], ...
%                                                     'nlfn', @zero_below_thresh)), ...
%                     MODULES.sum_fields.mdl(struct('inputs', {{'inhib', 'excit'}}, ...
%                                                   'output', 'stim'))};

% GROUP 4: POST-FILTER NONLINEARITIES
mm{4} = [];
mm{4}.nonl = {MODULES.passthru};
mm{4}.sig  = {MODULES.nonlinearity.mdl(struct('fit_fields', {{'phi'}}, ...
                                             'phi', [0 1 1 0], ...
                                             'nlfn', @sigmoidal))};
mm{4}.npnl = {MODULES.nonparm_nonlinearity};

% mm{4}.exp  = {MODULES.nonlinearity.mdl(struct('fit_fields', {{'phi'}}, ...
%                                               'phi', [1 1], ...
%                                               'nlfn', @exponential))};
% mm{4}.step = {MODULES.nonlinearity.mdl(struct('fit_fields', {{'phi'}}, ...
%                                               'phi', [0], ...
%                                               'nlfn', @zero_below_thresh))};
% mm{4}.poly = {MODULES.nonlinearity.mdl(struct('fit_fields', {{'phi'}}, ...
%                                               'phi', [1 1 1 1], ...
%                                               'nlfn', @polyval))};       

% GROUP 5: PERFORMANCE METRICS AND OPTIMIZATION TECHNIQUES
% TODO: Right now the names of these are critical because there is no way
% of hinting to the optimization routines how they should be tested.

% In general, fminlsq seems to work the best.
mm{5} = [];
mm{5}.fmin = {MODULES.correlation, ...
              MODULES.mean_squared_error.mdl(struct('output', 'score'))};   
mm{5}.lsq  = {MODULES.correlation, ...
              MODULES.mean_squared_error.mdl(struct('output', 'score'))};  
mm{5}.fminlsq  = {MODULES.correlation, ...
              MODULES.mean_squared_error.mdl(struct('output', 'score'))};
mm{5}.smooth = {MODULES.correlation, ...
               MODULES.mean_squared_error.mdl(struct('output', 'score', ...
                                              'smoothness_weight', 10^-6))};
mm{5}.jack = {MODULES.correlation, ...
               MODULES.mean_squared_error.mdl(struct('output', 'score'))};
mm{5}.twostep = {MODULES.correlation, ...
                 MODULES.mean_squared_error.mdl(struct('output', 'score'))};
mm{5}.threestep = {MODULES.correlation, ...
                 MODULES.mean_squared_error.mdl(struct('output', 'score'))};
             