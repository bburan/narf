* SUMMARY OF CHANGES:
  1) [X] Jackknifing is a generic FITTER function keyword and requires no special work.
         - Besides, we need to do jackknifing even on split models.
  2) [X] STACK is now a 2x deep cell array. XXX has no change.
  3) [X] Modules all have a 'splitter' fn and a 'unifier' fn
	 - The splitter function is called when append_module() is done
	 - The splitter accounts for data conditions
	   {[mdl1, dat1], [mdl2, dat2]} = splitter(STACK, XXX)
	 - The unifier brings back multiple data conditions
	   XXX{N+1} = unifier(x1{n+1), x2{n+1});
  4) [X] Pack and unpack_fittables now understand split parameters
  5) [X] Peeking at another module's data without using EXTRACT_MODULE_PARAMS() is now STRICTLY FORBIDDEN
         - You provide the index number, which you found previously with find_modules()
	 - {cellarrayofparams} = Extract_module_params(module_index, param) 
  6) [X] recalc_XXX now 
	   1. calls mdl.fn() on each split parameter set
	   2. calls mdl.unifier() on the XXX results of all of those
  7) [X] Whatever calls plot hooks in narf_modelpane now
  8) [X] Substantial work in utils/
	 All the functions which use STACK should now be more or less workable!	  
  9) [X] There are three splitter implementations available:
	 1. per-respfile
	 2. per-filecode category
	 3. all-files (No splitter provided)
  10) [X] There is one generic unifier
          1. Per-respfile merger
  11) [-] STACK{}.gh is now its own structure: NARFGUI
	  - [X] Ensure no more *.gh things exist
	  - [X] Ensure that all the plot_gui's now are in NARFGUI
	  - [ ] get_baphy_plot_controls
	  - [ ] Substantial work in narf_modelpane
  12) [ ] Substantial work in pretty much every module which touches STACK naively
	  - [ ] 
  13) [ ] Substantial work in narf_modelpane
	  Any search through the stack now has this possibility of multiple parameter sets!	 
           1. calls mdl.splitter() to get the number of parameter sets to do
	   2. Creates a corresponding number of axes() 
	   3. Calls the selected plot function on each one
	  Pretty much every time you use STACK{...} you need to check!	

* UNDUN
    sel.stimfile = popup2str(mdl.plot_gui.selected_stimfile_popup);
    sel.stim_idx = popup2num(mdl.plot_gui.selected_stim_idx_popup);
    sel.chan_idx = popup2num(mdl.plot_gui.selected_stim_chan_popup);

* Module Interface Changes
  - DO functions now get passed four arguments instead of two:
    | mdl   | Module parameter set                                                   |
    | x     | default xxx data to work on                                            |
    | stack | The whole stack. It's STRONGLY ENCOURAGED you don't actually use this. |
    | xxx   | The whole xxx. It's STRONGLY ENCOURAGED you not use this.              |

  - PLOT functions now get passed six arguments
    | selected | Struct containing plot_gui selections                            |
    | stack    | The whole stack up to this point, including alternate param sets |
    | xxx      | The whole xxx up to N+1 with the unified results                 |

  - These can easily be computed from stack and xxx
    | mdls   | cell array of module parameter sets for this module |
    | xprevs | cell array of split inputs                          |
    | xnexts | cell array of outputs before the unify              |
    | mdl    |                                                     |
    | xprev  |                                                     |
    | xnext  |                                                     |

  - Selected struct has these fields
    | selected.stimfile    | Selected stimfile              |
    | selected.stim_idx    | Selected stim idx              |
    | selected.chan_idx    | Default selected channel idx   |
    | selected.parmset_idx | Default selected parameter set (or this parmset) |

  - The selected struct is built by walking the NARFGUI array and merging fields

  - When a plot-gui is changed, it triggers a REFRESH_GUI from that point
    Model the logic on the recalc_xxx and it should be fine

  - Only remaining questions is should I
    1. Plot per parameter set and encapsulate loops?
    2. Plot entire thing

    I guess it makes more sense to plot the whole damn thing
    If I just want to plot part of it, I do: 

  - For encapsulation at some point, we may want to remove global defaults:
    1. We should pass a handle to the plot axes to the plot functions


* PLOTTING
  - [ ] Plot all output channels with different colors    (SHAREABLE METHOD) 
  - [ ] Plot just one output channel in black             (SHAREABLE METHOD)
  - [ ] Plot just one output channel as a spectrogram     (SHAREABLE METHOD)
  - [ ] Plot all output channels as a heatmap             (SHAREABLE METHOD)
  - [ ] Plot just the average response                    (Specific but similar to 'plot one channel')
  - [ ] Plot all output responses as a raster             (Specific...unless I want to raster time-scaled stuff?)
  - [ ] Plot specrogram + raster                          (specific, combo)
  - [ ] Plot active set of FIR coefs as heatmap           (SHAREABLE)
  - [ ] Plot all sets of FIR coefs as heatmap
  - [ ] Plot active set of FIR coefs as stem plot
  - [ ] Plot all intermediate channels for a single paramset ( FIR specific)
  - [ ] Plot the FIR output channel (1D) for a single/multiple param set
 
* Meta-Methods
** I need a generic plotting method which takes
  - A function that plots a single line
  - x axis vector-valued cell array {x1, x2, x3}
  - y axis matrix-valued cell array {Y1, Y2, Y3}
  - fieldnames (Assumed to be parameter set names)
  - channames (assumed to be channels and corresponding with Y's 2nd dimension)

** It should also:
   - Colors indicate channel: b, g, r, c, m, 
   - Line types:    -, --, -., :, o-, x-,
   - Automatic legend, X axis, Y axis, etc
   - plot(dat.(mdl.output_stim_time), ...
       dat.(mdl.output_stim)(:, sel.stim_idx, sel.chan_idx), 'k-');

* Why the plot functions have to change so much:
  Because right now in EVERY single plot function, we check the status of a GUI that may not exist
  For better flexibility, we should allow plotting to occur programmatically
  This can only occur if plot functions are GIVEN the GUI status as an argument

* Have the FIR module be MIMO, and then SUM the outputs
  Is it useful to do this to simplify plot routines? Or not?
  
* Bayesian perspective
  You have a model structure (STACK)
  You have several model parameter sets (Sideways sets of parameters in STACK)
  Each of those has a likelihood/data chain (XXX)
  Now that we can have multiple parameter sets, we can even have ENSEMBLE models
  (Use a gaussian random splitter, and a mean unifier or one that discards outliers)
  
* Places to correct plot function stuff
  - [ ] narf_modelpane.m:        m.plot_fns{idx}.fn(STACK(1:mod_idx), XXX(1:mod_idx+1));

* Architectual Improvements
  1. [ ] Make the fits run faster by removing then re-adding the 'test_set' data after fitting process
  2. [ ] Sparsity+ smoothness penaltiy is now part of the fitter, not the model
	 Some models have multiple FIRs, and that becomes too much logic to put in a module
  3. [ ] Make a 2D NPNL heightmap nonlinearity
	 Input X is the exitation
	 Input Y is the inhibition
	 Returns Z, the height of the map
	 Data will probably NOT be scattered uniformly around the map.
  4. [ ] Bayesian Performance Metrics
	 Why: Noise model entropy is a metric of performance. (If best-fit noise distribution has low entropy, we know _more_ about the system) 
	 Why: Likelihood is probably a better metric than MSE since large outliers may not affect it as much?

* SMALL CORRECTIONS AUDIT LIST
  1. [ ] Smooth scatter plots do testing / training simultaneously
  2. [-] Clean up distribution of code before a modelfit
	 - [ ] Function which distributes GIT to workers before enqueing models
	 - [X] Checks local repository is clean
  3. [-] NARF Browser Improvements
         - [X] Scatter plot test/train button
         - [ ] Heat Map current display button	
  4. [ ] Repair NarfModelpane
         - [ ] Displays model name, training set, test set, and other important info at bottom of window
         - [ ] Provide a dropdown to pick more fitters
	 - [ ] Standardized colors for all module plots
  5. [ ] Replace all the 'true' and 'false' arguments with textual flags and varargin that are more descriptive
  6. [ ] IRRITATION: Why doesn't it show the model save filename so I can see which file I just loaded if I forgot?
  7. [ ] IRRITATION: Why doesn't every plotted signal have a legend?
  8. [ ] IRRITATION: Why don't the X (or at least the Y) axes have scales?
  9. [ ] IRRITATION: Why are the editable text boxes so damn small?
  10. [ ] Is this line fine with the closures? m.plot_fns{1}.fn = @(stack, xxx) do_plot_channel_vs_time(stack, xxx, m.time, m.output);
  11. [ ] Remember to invalidate data BELOW the present point on a table-edit callback... and to update the gui to reflect this!
  12. [ ] Make sure that fitters return specific codes indicating how they terminated
  13. [ ] Pull out repeated code blocks in the fitters (because they are all pretty much the same damn thing over and over again)
  14. [ ] Antialiasing problem when saving images
  15. [ ] MODULE: Standardized single/multi channel gammatone filter
  16. [ ] MODULE: Standardized single/multi channel elliptic filter 
  17. [ ] FN: 'set_module_field' (finds module, sets field, so you can mess with things more easily in scripts)
  18. [ ] Make Concat Second Order Terms work for any higher order nchoosek type stuff
  19. [ ] FN: Cover an input space logarithmically with filters
  20. [ ] Add error handling (catch/throw) around EVERY CALL to a user defined function, trigger popup?
  21. [ ] Ensure that no closures of data are being done by methods. Methods should accept the module object as their first argument, not close over anything.
  22. [ ] It's not quite right to have the 'replot' command be part of the the 'plot_popup fn callback'. Needs to be re-thought
  23. [ ] MODULE: Add a module which can pick out a particular dimension from a vector and give it a name as a signal
  24. [ ] MODULE: Build a non-cheating model which extracts envelopes directly from the WAV files using an elliptic or gammatone prefilter
  25. [ ] IRRITATION: Why can't I resize windows?
  26. [ ] Repair histogram plots when doing scatter stuff so you can see densities better relative to 
  27. [ ] Grep for TODO's, FIXME's, etc in existing files and add them to this list

* ENQUEUING MANAGER PROGRAM:
  1. Should Batching should work like this?
     + Batch model scripts can share structure. right now all the batches have pretty much identical scripts!
     + When work is enqueued, it goes into the NARF table, which has a 'complete?' flag
     + Any number of PCs query the DB, try to get 'incomplete' flagged models. DB is atomic, handles conflicts and negates need for server.
     + They compute those models, then return values.
     + If desired, a local 'manager' on each PC can watch processes, handle timeouts, etc
     + Negates need for SSH credentials everywhere, too.
  2. Or like this?
     + Do an SQL query to NarfResults to see what exists
     + Display models to be trained, already trained
     + Allow deletions of existing models
     + Display keyword selectors for models at the top
     + Display keyword selectors for fitters at the top
     + Display selectors for which cellids can be trained
     + Checkbox management so that only certain models can be enqueued

* SAFETY VERIFICATION PROGRAM:
  1. Create a test/ directory with many test functions in it
     Each test function:
     - creates a default XXX{1}
     - Puts a single module on the stack
     - Recomputes XXX(1)
     - Checks output vs predetermined values
  2. Check that all modules work independently as expected
  3. Checks that DB and modelfiles still sync up

* THE GREAT NAME REPLACING PROPOSAL
  1. [ ] XXX -> 
  2. [ ] STACK -> 
  3. [X] STACK.gh -> NARFGUI
  4. [ ] META -> ModelInfo
  5. [ ] FITTER
  6. [ ] MODULES
  7. [ ] recalc_xxx -> calc_xxx
  8. [ ] Make a list of every function used purely for side effects, and rename it with a ! at the end
  9. [ ] "training set" -> "estimation set"
  10. [ ] "test set" -> "Validation set"
  11. [ ] Name convention of STACK vs stack, XXX vs xxx and the difficulty in understanding which one we are looking at! 
	  Lots of hidden assumptions here which are a problem. Plot modules have access to AFTER data, too.

* TECHNICALLY HARDER CHUNKS OF WORK
  1. [ ] Depression model fits for 240, 242
  2. [ ] Inhibition/Excitiation model
  4. [ ] GMM without slow EM step:
	 For each point, take K nearest neighbors. 
	 Compute 2D gaussian for that point. 
	 Flatten that 2D gaussian and push into SENL's 1D input
  5. [ ] Log Likelihood Fitter: (Any noise model, not just gaussian)
	 MSE is biased towards gaussian noise models, and for real-life data sets the probability tails are always heavier than a gaussian.
	 Subcomponents:
	 - [ ] inter_spike_intervals computation module
         - [ ] bayesian_likelihood() perf metric module
  6. [ ] ABCD Control Blocks with arbitrary functions (start with 1st and second degree polynomials)
  7. [ ] Use a single wavelet transform in place of downsampling + FIR filter
  8. [ ] Write a crash course guide on using NARF

* DEFERRED
** Stephen's boosting verification
  1. A Shrinking step size is stupid simple. Is there a better way?
  2. Can we retire the analysis/TSP files?
  3. Can I retire the modules/exp_filter? 

* DISCARDED WORK
  1. [ ] Push all existing files into the database
  2. [ ] MODULE INIT: Make a module which has a complex init process
	 1) Creates a spanning filterbank of gammatones
	 2) Trains the FIR filter on that spanning filterbank
	 3) Picks the top N (Usually 1, 2 or 3) filters based on their power
	 4) Crops all other filters
  3. [ ] FIX POTENTIAL SOURCE OF BUGS: Not all files have a META.batch property (for 240 and 242)
  4. [ ] A histogram heat map of model performance for each cell so you can see distribution of model performance (not needed now that I have cumulative dist plotter)
  5. [ ] If empty test set is given for a cellid, what should we do? Hold 1 out cross validation? 
  6. [ ] Fix EM conditioning error and get gmm4 started again (Not sure how to fix!)
  7. [ ] Address question: Does variation in neural fuction in A1 follow a continuum, or are there visible clusters?
  8. [ ] A 2D sparse bayes approach. Make a 2D matrix with constant shape (elliptical, based on local deviation of N nearest points) to make representative gaussians, then flatten to 1D to make basis vectors fed through SB.
  9. [ ] CLEAN: Compare_models needs to sort based on training score if test_score doesn't exist.
  10. [ ] FITTER: Regularized boosting fitter
  11. [ ] FITTER: Automatic Relevancy Determination (ARD) + Automatic Smoothness Determination (ASD)
  12. [ ] FITTER: A stronger shrinkage fitter (Shrink by as much as you want).
  13. [ ] FITTER: Three-step fitter (First FIR, then NL, then both together).
  14. [ ] FITTER: Multi-step sparseness fitters (Fit, sparseify, fit, sparsify, etc). Waste of time
  15. [ ] MODULE: Make a faster IIR filter with asymmetric response properties 
  16. [ ] Make logging work for the GUI by including the log space in narf_modelpane?
  17. [ ] IRRITATION: Why doesn't 'nonlinearity' module default to a sigmoid with reasonable parameters?
  18. [ ] IRRITATION: Why isn't there progress in the GUI when fitting?
  19. [ ] IRRITATION: Why isn't there an 'undo' function?
  20. [ ] IRRITATION: Why can't I edit a module type in the middle of the stack via the GUI?
  21. [ ] Right now, you can only instantiate a single GUI at a time. Could this be avoided and the design made more general?	  
	  To do this, instead of a _global_ STACK and XXX, they would be closed-over by the GUI object.
	  Then, there would need to be a 'update-gui' function which can use those closed over variables.
	  That fn could be called whenever you want to programmatically update it. 	  	  	 
  22. [ ] Make gui plot functions response have two dropdowns to pick out colorbar thresholds for easier visualization?
  23. [ ] Make it so baphy can be run _twice_, so that raw_stim_fs can be two different values (load envelope and wav data simultaneously)
  24. [ ] MODULE: Add a filter that processess phase information from a stimulus, not just the magnitude
  25. [ ] Write a function which swaps out the STACK into the BACKGROUND so you can 'hold' a model as a reference and play around with other settings, and see the results graphically by switching back and forth.
  26. [ ] Try adding informative color to histograms and scatter plots
  27. [ ] Try improving contrast of various intensity plots
  28. [ ] Put a Button on the performance metric that launches an external figure if more plot space is needed.
  29. [ ] Add a GUI button to load_stim_from_baphy to play the stimulus as a sound
  30. [ ] FITTER: Crop N% out fitter:
	    1) quickfits FIR
	    2) then quickfits NL
	    3) measures distance from NL line, marks the N worst points
	    4) Looks them up by original indexes (before the sort and row averaging)
	    5) Inverts nonlinearity numerically to find input
	    6) Deconvolves FIR to find the spike that was bad
	    7) Deletes that bad spike from the data
	    8) Starts again with a shrinkage fitter that fits both together
  31. [ ] Expressing NL smoothness regularizer as a matrix
	    A Tikhonov matrix for regression: 
	    diagonals are variance of each coef.
	    2nd diagonals would add some correlation from one FIR coef to the next (smoothness?).
  32. [ ] Sparsity check:
	   For each model,
              for 1:num coefs
               Prune the least important coef
		plot performance
              Make a plot of the #coefs vs performance
  33. [ ] A check of NL homoskedasticity (How much is the variance changing along the abscissa)	     
  34. [ ] FITTER: SWARM. Hybrid fit routine which takes the top N% of models, scales all FIR powers to be the same, then shrinks them.
  35. [ ] Get a histogram of the error of the NL. (Is it Gaussian or something else?)
  36. [ ] Have a display of the Pareto front (Dominating models with better r^2 or whatever)
  37. [ ] FN: Searches for unattached model and image files and deletes them
  38. [ ] Models need associated 'summarize' methods in META
	  Why: Need to extract comparable info despite STACK positional differences in model structure.
	  Why: Need a general interface to plot model summaries for wildly different models
	  Difficulty: Auto-generated models will need some intelligence as to how to generate summarize methods for themselves
  39. [ ] DB Bug Catcher which verifies that every model file in /auto/data/code is in the DB, and correct
	  Why: Somebody could easily put the DB and filesystem out of sync.
	  Why: image files could get deleted
	  Why: DB table could get corrupted
	  Why: Also, we need to periodically re-run the analysis/batch_240.m type scripts to make sure they are all generated and current
  40. [ ] Put a line in fit_single_model that pulls the latest GIT code before fitting?
  41. Fit combo: revcorr->boost (what we do now)
  42. Fit combo: revcorr->boost->sparsify->boost   (Force sparsity and re-boost)
  43. Fit combo: prior->boost
  44. Fit combo: revcorr->boost_with_increasing_sparsity_penalty
  45. Fit combo: revcorr->boost_with_decreasing_sparsity_penalty
  46. Fit combo: zero->boost 
  47. Fit combo: Fit at 100hz, then use that to init a fit at 200Hz, then again at 400Hz.
  48. Replace my nargin checks with "if ~exist('BLAH','var'),"
  48. sf=sf{1}; should be eliminated IN EVERY SINGLE FILE! 

* Crazyboost
  How's this for a fitter?
  Boosting works well, and tries every possible step before taking a new one.
  That's good and deterministic, but maybe we could speed things up by randomly sorting the steps (so as not to be biased towards early values)
  Then just take a step _any_ time it improves the score
  It would take many more steps each iteration.
  No guarantee it would converge, but maybe we could do it a few times.
