* NEXT STEPS:
  1. [X] Move 'define_dims' to an 'incomplete' directory of code that isn't used yet.
  2. [X] Go through utils/ and optimization, move unused things to graveyard
  3. [X] Make a function which extracts desired information from SAVED FILES: 
  4. [ ] Find that weird bug that still exists when saving/loading files
	 
  5. [ ] Examine the cause of the error when loading "por022b12_a_TSP"
  6. [ ] Try nlinfit 
  7. [ ] Try fminval
  8. [ ] REFACTORING AS SOON AS STEPHEN/DANIELA'S ANALYSIS IS READY
         1) Make the list of models a global, so I don't have it scattered around everywhere in my code.
         2) Many repeated blocks of code have evolved and need to be destroyed.
         3) Paths have become a bit messy: grep for NARF_PATH and correct (also: replace with filesep when possible)
         4) Names probably could use some rethinking as well, especially defaults (like using 'stim' default even in the fitting algorithms, for example)
         5) Move the 'gui' stuff to a separate global structure?
         6) Cleaner way of building models in a script than accessing by index number?
         7) Use this idiom more often to search through struct or cell arrays:
	    hits = arrayfun(@(x)strcmp(x.stimfile, sf), XXX{2}.cfd);   % Use cellfun instead of arrayfun if needed.
         8) Look for obvious repetition and make some more functions in util/
         9) Remove/rename useless functions in util that have accumulated.
         10) In retrospect, 'plot_gui' stuff probably shouldn't be stored in the XXX or STACK structures...should it be in a 3rd structure?
         11) It's not quite right to have the 'replot' command be part of the the 'plot_popup fn callback'. Needs to be re-thought.
         12) Right now, you can only instantiate a single GUI at a time. Could this be avoided and the design made more general?
         13) Go through the TODO's in existing files
         14) Ensure that no closures of data are being done by methods. Methods should accept the module object as their first argument, not close over anything.
         15) make anything named 'do_' into a method for use with modules?
         16) make anything named 'update_' into a function used purely for its side effects
  9. [ ] Build a non-cheating model which extracts envelopes directly from the WAV files using a prefilter

* DISCUSSIONS
  Observation: Be very careful using sigmoid nonlinearity: it tends to squash data into two groups. It almost always helps to widen the sigma parameter before fitting again.

* DESIGN QUESTIONS
  1. How can sane initial conditions for optimization be automatically arrived at without extra script-writing?
  2. How can jack-knifing be integrated in to the optimization routine to prevent over-fitting?
     for each stim file:
     n_j = min(length(number_of_stim_indexes), 10);
     training_set = first n_j / number_of_stim_indexes
     test_set = remainder of stim_indexes
     Train
     test
     Scale by variance when taking the mean off all of those?
  3. Is punting on initial conditions an ok thing to do?
  4. How should models be automatically generated in a quick and scriptable way?
  5. How can fitting constraints be added to each module? 
  6. How can design internal degrees of freedom be detected and corrected during optimization?

* SCIENTIFIC QUESTIONS
  1. Should training set data be weighted by manually-set stimfile weights to account for biasing effect of sheer large numbers of samples?
  2. By how much does training on more than one data set improve test performance?

* LATER TODO LIST
  1. [ ] Add a module which can pick out a particular dimension from a vector and give it a name as a signal
  2. [ ] Make inter_spike_intervals work
  3. [ ] Make bayesian_likelihood() work
  4. [ ] Make Concat Second Order Terms work for any higher order nchoosek type stuff
  5. [ ] Write a 'scaled boosting' algorithm, which takes a step in the direction inversely proportional to power of that channel (reweighting the channels by their power, essentially)
  6. [ ] Get linear_fit_with_preprocessing working again (working from a WAV file, that is)
  7. [ ] Make gammatone filter bank work like elliptic bandpass filter so interface is standard
  8. [ ] Provide functions to cover the input space logarithmically with filters
  9. [ ] Write a crash course guide on using NARF
  10. [ ] Remember to invalidate data BELOW the present point on a table-edit callback... and to update the gui to reflect this!
  11. [ ] Make logging work for the GUI by including the log space in narf_modelpane?
  12. [ ] Delete the GUI objects whenever you 'apply' since they may need to be recreated?
  13. [ ] Write a 'conjugate boosting' algorithm, which is normal boosting but takes steps in a single direction until the objective function stops improving.
  14. [ ] Write several different performance metric functions: MSE and a point-process fit
  15. [ ] Write a jack-knifing optimization which can work with any of the optimization modules 
  16. [ ] Single channel gammatone filter (for speed, once sensitivity has been identified)
  17. [ ] Add a method to "save analysis", connecting the stimfile train/test sets, model structure and params, optimization method, and GIT code hash number all together in a single, savable structure.
  18. [ ] Add error handling (catch/throw) around EVERY CALL to a user defined function
  19. [X] Handle NaN's better...right now they can cause problems! (Use nanmean())
  20. [ ] Add a GUI button to load_stim_from_baphy to play the stimulus as a sound?
  21. [ ] Put a Button on the performance metric that launches an external figure if more plot space is needed.
  22. [ ] Make it so baphy can be run _twice_, so that raw_stim_fs can be two different values (load envelope and wav data simultaneously)
  23. [ ] Suggest an improvement: Use BAPHY to cache intermediate values
	  
* LUXURY, UNESSENTIAL TODO ITEMS 
  - [ ] Make raw/stimulus response have two dropdowns to pick out colorbar thresholds for easier visualization
  - [ ] Add a filter that processess phase information from a stimulus, not just the magnitude
  - [ ] Write a function which swaps out the STACK into the BACKGROUND so you can 'hold' a model as a reference and play around with other settings, and see the results graphically by switching back and forth.
  - [ ] Write dbchoosecellfiles()
  - [ ] Use inter_curve_v3 to interactively make FIR things
  - [ ] Try adding color to histograms and scatter plots
  - [ ] Try improving contrast of various intensity plots
  - [ ] Add BIC or AIC to model comparison data
  - [ ] Optimization report card and status information logged
  - [ ] Rank model fits and plot correlations
  - [ ] New training method:
	1. Search for coefficients from a spanning filter bank
        2. Find the signal contributing most (using the FIR coefficients)
	3. Do a second filter bank that is only an octave wide, with the signal in the center, to get more substructure
	   
