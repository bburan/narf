function demotree()
% Creates a demo tree-traversal program
% Two fittable OZGFs, two nonlinearities, two p1z1s, and one 

global MODULES STACK XXX META;

load_fs = 50000;
samp_fs = 200;

append_module(MODULES.load_stim_resps_from_baphy.mdl(...
                           struct('raw_resp_fs', samp_fs, ...
                                  'raw_stim_fs', load_fs,...
                                  'include_prestim', true, ...
                                  'stimulus_format', 'wav'))); 

% Passthru modules rename the signal in order to allow independent
% downsampling to occur for each path (otherwise, during the downsampling
% step, we would need to evaluate both PZ filters after the downsample
append_module(MODULES.passthru.mdl(struct(...
                       'input', 'stim_time', ...
                       'output', 'stim_timeA')));  
                   
append_module(MODULES.passthru.mdl(struct(....
                       'input', 'stim_time', ...
                       'output', 'stim_timeB')));  

% CHANNEL A - Starts at a low freq and goes up, I hope.
append_module(MODULES.pz_wavelet.mdl(...
                struct('fit_fields', {{'center_freq_khz', 'Q_factor', 'zeros'}}, ...
                       'N_order', 4, ...
                       'M_order', 1, ...
                       'zeros', [0], ...
                       'center_freq_khz', 1.7, ...                       
                       'Q_factor', 0.7, ... 
                       'delayms', 0, ... 
                       'input', 'stim', ...
                       'time', 'stim_timeA', ...
                       'output', 'stimA')));  
                                    
append_module(MODULES.downsample_signal.mdl(...
        struct('input', 'stimA', ...
               'input_freq', load_fs, ...
               'input_time', 'stim_time', ...
               'output', 'stimA', ...
               'output_freq', samp_fs, ...
               'output_time', 'stim_timeA', ...
               'downsampler', @decimate))); % Try @decimate, or @conv_fn, or @resample

append_module(MODULES.normalize_channels.mdl(...
        struct('input', 'stimA', 'time', 'stim_timeA', ...
               'output', 'stimA', 'force_positive', true)));

append_module(MODULES.nonlinearity.mdl(struct('phi', [-2 -100 0.05], ...
                                              'nlfn', @nl_log, ...
                                              'input_stim', 'stimA', ...
                                              'time', 'stim_timeA', ...
                                              'output', 'stimA', ...
                                              'fit_fields', {{'phi'}})));
                                          
append_module(MODULES.normalize_channels.mdl(...
        struct('input', 'stimA', 'time', 'stim_timeA', ...
               'output', 'stimA', 'force_positive', true)));

append_module(MODULES.pole_zeros.mdl(...
                struct('fit_fields', {{'poles', 'zeros', 'delays'}}, ...
                       'input', 'stimA', ...
                       'time', 'stim_timeA', ...
                       'output', 'stimA', ... 
                       'n_poles', 2, ...
                       'n_zeros', 1, ...
                       'n_inputs', 1)));           

append_module(MODULES.normalize_channels.mdl(struct('input', 'stimA', ...
        'output', 'stimA', 'force_positive', true)));                                         
    
% CHANNEL B - Starts at a high freq and comes down, I hope.
append_module(MODULES.pz_wavelet.mdl(...
                struct('fit_fields', {{'center_freq_khz', 'Q_factor', 'zeros'}}, ...
                       'N_order', 4, ...
                       'M_order', 1, ...
                       'zeros', [0], ...
                       'center_freq_khz', 15.0, ...                       
                       'Q_factor', 0.7, ... 
                       'delayms', 0, ... 
                       'input', 'stim', ...
                       'time', 'stim_timeB', ...
                       'output', 'stimB')));  

append_module(MODULES.normalize_channels.mdl(...
        struct('input', 'stimB', 'time', 'stim_timeB', ...
               'output', 'stimB', 'force_positive', true)));      

append_module(MODULES.downsample_signal.mdl(...
        struct('input', 'stimB', ...
               'input_freq', load_fs, ...
               'input_time', 'stim_time', ...
               'output', 'stimB', ...
               'output_freq', samp_fs, ...
               'output_time', 'stim_timeB', ...
               'downsampler', @decimate))); % Try @decimate, or @conv_fn, or @resample

append_module(MODULES.nonlinearity.mdl(struct('phi', [-2 -100 0.05], ...
                                              'nlfn', @nl_log, ...
                                              'input_stim', 'stimB', ...
                                              'time', 'stim_timeB', ...
                                              'output', 'stimB', ...
                                              'fit_fields', {{'phi'}})));
                                          
append_module(MODULES.normalize_channels.mdl(...
        struct('input', 'stimB', 'time', 'stim_timeB', ...
               'output', 'stimB', 'force_positive', true)));    

append_module(MODULES.pole_zeros.mdl(...
                struct('fit_fields', {{'poles', 'zeros', 'delays'}}, ...
                       'input', 'stimB', ...
                       'time', 'stim_timeB', ...
                       'output', 'stimB', ... 
                       'n_poles', 2, ...
                       'n_zeros', 1, ...
                       'n_inputs', 1)));

append_module(MODULES.normalize_channels.mdl(struct('input', 'stimB', ...
        'output', 'stimB', 'force_positive', true)));
    
% And now the unification of the two trees
append_module(MODULES.passthru.mdl(struct(....
                       'input', 'stim_timeA', ...
                       'output', 'stim_time')));  

append_module(MODULES.concatenate_channels.mdl(...
    struct('inputs', {{'stimA', 'stimB'}}, ...
           'time', 'stim_time', ...
           'output', 'stim')));

append_module(MODULES.nonlinearity.mdl(...
    struct('fit_fields', {{'phi'}}, ...
           'phi', repmat([8 150 15 0.7], 2, 1), ...
           'nlfn', @nl_dexp)));

% Note how this is NOT FIT, since it is redundant if the previous
% nonlinearities are fit with gain and zero terms.
append_module(MODULES.weight_channels.mdl(...
       struct('weights', ones(2, 1), ...
              'y_offset', 0.00)));
          
fit09();